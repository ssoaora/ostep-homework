
# 개요

이 프로그램은 세그먼테이션이 있는 시스템에서 주소 변환이 어떻게 수행되는지 확인할 수 있게 해줍니다. 이 시스템에서 사용하는 세그먼테이션은 매우 간단합니다: 주소 공간에는 단 *두 개*의 세그먼트만 있습니다. 프로세스에 의해 생성된 가상 주소의 최상위 비트는 주소가 어느 세그먼트에 있는지를 결정합니다: 0은 세그먼트 0 (예: 코드와 힙이 위치하는 곳)이고, 1은 세그먼트 1 (스택이 위치하는 곳)입니다. 세그먼트 0은 양의 방향으로 성장하고 (더 높은 주소로), 세그먼트 1은 음의 방향으로 성장합니다.

시각적으로, 주소 공간은 다음과 같습니다:

```plaintext
 --------------- 가상 주소 0
 |    세그0     |
 |             |
 |             |
 |-------------|
 |             |
 |             |
 |             |
 |             |
 |(할당되지 않음)|
 |             |
 |             |
 |             |
 |-------------|
 |             |
 |    세그1     |
 |-------------| 가상 주소 최대값 (주소 공간의 크기)
```

세그먼테이션에서는 각 세그먼트마다 베이스/리미트 쌍의 레지스터가 있습니다. 따라서 이 문제에서는 두 개의 베이스/리미트 쌍이 있습니다. 세그먼트 0의 베이스는 세그먼트 0의 *상단*이 물리 메모리에 배치된 물리 주소를 나타내고, 리미트는 세그먼트의 크기를 나타냅니다. 세그먼트 1의 베이스는 세그먼트 1의 *하단*이 물리 메모리에 배치된 위치를 나타내며, 해당 리미트는 세그먼트의 크기(또는 음의 방향으로 얼마나 성장하는지)를 나타냅니다.

이전과 마찬가지로, 세그먼테이션에 대한 이해를 테스트하기 위해 프로그램을 실행하는 두 단계가 있습니다. 먼저 "-c" 플래그 없이 실행하여 주소 변환 세트를 생성하고 직접 주소 변환을 올바르게 수행할 수 있는지 확인하십시오. 그런 다음 완료되면 "-c" 플래그를 사용하여 실행하여 답을 확인하십시오.

예를 들어, 기본 플래그로 실행하려면 다음을 입력하십시오:

```sh
prompt> ./segmentation.py 
```

또는

```sh
prompt> python ./segmentation.py 
```

다음과 같은 결과를 볼 수 있습니다:

```sh
  ARG seed 0
  ARG address space size 1k
  ARG phys mem size 16k
  
  세그먼트 레지스터 정보:

    세그먼트 0 베이스  (양의 방향으로 성장) : 0x00001aea (십진수 6890)
    세그먼트 0 리미트                  : 472

    세그먼트 1 베이스  (음의 방향으로 성장) : 0x00001254 (십진수 4692)
    세그먼트 1 리미트                  : 450

  가상 주소 추적
    VA  0: 0x0000020b (십진수:  523) --> PA 또는 세그먼테이션 위반?
    VA  1: 0x0000019e (십진수:  414) --> PA 또는 세그먼테이션 위반?
    VA  2: 0x00000322 (십진수:  802) --> PA 또는 세그먼테이션 위반?
    VA  3: 0x00000136 (십진수:  310) --> PA 또는 세그먼테이션 위반?
    VA  4: 0x000001e8 (십진수:  488) --> PA 또는 세그먼테이션 위반?

  각 가상 주소에 대해 변환되는 물리 주소를 적거나 범위를 벗어난 주소(세그먼테이션 위반)라고 적으십시오. 이 문제에서는 두 개의 세그먼트가 있는 간단한 주소 공간을 가정해야 합니다: 가상 주소의 최상위 비트를 사용하여 가상 주소가 세그먼트 0 (topbit=0) 또는 세그먼트 1 (topbit=1)에 있는지 확인할 수 있습니다. 주어진 베이스/리미트 쌍은 세그먼트에 따라 다른 방향으로 성장합니다. 즉, 세그먼트 0은 양의 방향으로 성장하고, 세그먼트 1은 음의 방향으로 성장합니다.  
```

그런 다음 가상 주소 추적에서 변환을 계산한 후 "-c" 플래그를 사용하여 프로그램을 다시 실행하십시오. 다음과 같은 결과를 볼 수 있습니다 (중복 정보 제외):

```sh
  가상 주소 추적
    VA  0: 0x0000020b (십진수:  523) --> 세그먼테이션 위반 (SEG1)
    VA  1: 0x0000019e (십진수:  414) --> 유효한 SEG0: 0x00001c88 (십진수: 7304)
    VA  2: 0x00000322 (십진수:  802) --> 유효한 SEG1: 0x00001176 (십진수: 4470)
    VA  3: 0x00000136 (십진수:  310) --> 유효한 SEG0: 0x00001c20 (십진수: 7200)
    VA  4: 0x000001e8 (십진수:  488) --> 세그먼테이션 위반 (SEG0)
```

보시다시피, -c 플래그를 사용하면 프로그램이 주소를 변환하여 세그먼테이션을 사용하는 시스템이 주소를 어떻게 변환하는지 이해할 수 있는지 확인할 수 있습니다.

물론, 다른 문제를 생성하기 위해 사용할 수 있는 몇 가지 매개변수가 있습니다. 특히 중요한 매개변수는 -s 또는 -seed 매개변수로, 다른 랜덤 시드를 전달하여 다른 문제를 생성할 수 있습니다. 물론, 문제를 생성하고 해결할 때 동일한 랜덤 시드를 사용해야 합니다.

다른 크기의 주소 공간과 물리 메모리를 사용하여 실험할 수 있는 몇 가지 매개변수도 있습니다. 예를 들어, 작은 시스템에서 세그먼테이션을 실험하려면 다음을 입력할 수 있습니다:

```sh
prompt> ./segmentation.py -s 100 -a 16 -p 32
ARG seed 0
ARG address space size 16
ARG phys mem size 32
 
세그먼트 레지스터 정보:

  세그먼트 0 베이스  (양의 방향으로 성장) : 0x00000018 (십진수 24)
  세그먼트 0 리미트                  : 4

  세그먼트 1 베이스  (음의 방향으로 성장) : 0x00000012 (십진수 18)
  세그먼트 1 리미트                  : 5

가상 주소 추적
  VA  0: 0x0000000c (십진수:   12) --> PA 또는 세그먼테이션 위반?
  VA  1: 0x00000008 (십진수:    8) --> PA 또는 세그먼테이션 위반?
  VA  2: 0x00000001 (십진수:    1) --> PA 또는 세그먼테이션 위반?
  VA  3: 0x00000007 (십진수:    7) --> PA 또는 세그먼테이션 위반?
  VA  4: 0x00000000 (십진수:    0) --> PA 또는 세그먼테이션 위반?
```

이 명령은 32바이트 물리 메모리에 배치된 16바이트 주소 공간에 대한 가상 주소를 생성하도록 프로그램에 지시합니다. 결과 가상 주소는 매우 작습니다 (12, 8, 1, 7, 0). 또한 프로그램은 적절하게 작은 베이스 레지스터와 리미트 값을 선택합니다. -c 플래그를 사용하여 답을 확인하십시오.

이 예제는 각 베이스 쌍이 정확히 무엇을 의미하는지 보여줍니다. 예를 들어, 세그먼트 0의 베이스는 물리 주소 24 (십진수)로 설정되고 크기는 4바이트입니다. 따라서 *가상* 주소 0, 1, 2, 3은 세그먼트 0에 있으며 유효하며, 각각 물리 주소 24, 25, 26, 27로 매핑됩니다.

조금 더 까다로운 것은 음의 방향으로 성장하는 세그먼트 1입니다. 위의 작은 예제에서 세그먼트 1의 베이스 레지스터는 물리 주소 18로 설정되고 크기는 5바이트입니다. 이는 가상 주소 공간의 마지막 다섯 바이트, 즉 11, 12, 13, 14, 15가 유효한 가상 주소이며, 각각 물리 주소 13, 14, 15, 16, 17로 매핑된다는 것을 의미합니다.

이해가 되지 않는다면 다시 읽어보십시오. 이러한 문제를 해결하려면 이 작동 방식을 이해해야 합니다.

-a 또는 -p 플래그에 "k", "m", 또는 "g"를 붙여서 더 큰 값을 지정할 수 있습니다. 예를 들어, 1MB 주소 공간을 32MB 물리 메모리에 설정하여 번역을 수행하려면 다음을 입력할 수 있습니다:

```sh
prompt> ./segmentation.py -a 1m -p 32m
```

더 구체적으로 설정하려면 --b0, --l0, --b1, --l1 레지스터를 사용하여 베이스 레지스터와 리미트 레지스터 값을 직접 설정할 수 있습니다. 시도해 보십시오.

마지막으로, 언제든지

```sh
prompt> ./segmentation.py -h 
```

를 실행하여 플래그와 옵션의 전체 목록을 확인할 수 있습니다.

즐기세요!
