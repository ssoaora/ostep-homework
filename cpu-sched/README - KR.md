
# 개요

이 프로그램 `scheduler.py`는 다양한 스케줄러가 응답 시간, 반환 시간, 총 대기 시간과 같은 스케줄링 메트릭에서 어떻게 성능을 발휘하는지 확인할 수 있게 해줍니다. 세 가지 스케줄러가 "구현"되어 있습니다: FIFO, SJF, RR.

프로그램을 실행하는 데는 두 단계가 있습니다.

먼저, -c 플래그 없이 실행하십시오: 이는 문제를 해결하는 방법을 보여주지만 답을 공개하지 않습니다. 예를 들어, FIFO 정책을 사용하여 세 개의 작업에 대한 응답, 반환 및 대기 시간을 계산하려면 다음을 실행하십시오:

```sh
prompt> ./scheduler.py -p FIFO -j 3 -s 100
```

작동하지 않으면 다음을 시도하십시오:

```sh
prompt> python ./scheduler.py -p FIFO -j 3 -s 100
```

이는 FIFO 정책과 세 개의 작업, 그리고 중요한 랜덤 시드 100을 지정합니다. 이 정확한 문제에 대한 해답을 보려면 동일한 랜덤 시드를 다시 지정해야 합니다. 실행해보고 어떤 일이 일어나는지 봅시다. 다음과 같은 결과를 볼 수 있습니다:

```sh
prompt> ./scheduler.py -p FIFO -j 3 -s 100
ARG policy FIFO
ARG jobs 3
ARG maxlen 10
ARG seed 100

여기 각 작업의 실행 시간이 포함된 작업 목록이 있습니다:
  작업 0 (길이 = 1)
  작업 1 (길이 = 4)
  작업 2 (길이 = 7)
```

각 작업의 반환 시간, 응답 시간, 대기 시간을 계산하십시오. 완료되면 동일한 인수로 프로그램을 다시 실행하되 -c 플래그를 사용하여 답을 확인하십시오. -s <숫자> 또는 자신의 작업 목록(-l 10,15,20 등)을 사용하여 다른 문제를 생성할 수 있습니다.

이 예에서 볼 수 있듯이 세 개의 작업이 생성됩니다: 길이 1의 작업 0, 길이 4의 작업 1, 길이 7의 작업 2. 프로그램에서 언급한 것처럼 이를 사용하여 통계를 계산하고 기본 개념을 이해했는지 확인할 수 있습니다.

완료되면 동일한 프로그램을 사용하여 문제를 "해결"하고 작업이 올바르게 수행되었는지 확인할 수 있습니다. 이를 위해 "-c" 플래그를 사용하십시오. 출력 결과는 다음과 같습니다:

```sh
prompt> ./scheduler.py -p FIFO -j 3 -s 100 -c
ARG policy FIFO
ARG jobs 3
ARG maxlen 10
ARG seed 100

여기 각 작업의 실행 시간이 포함된 작업 목록이 있습니다:
  작업 0 (길이 = 1)
  작업 1 (길이 = 4)
  작업 2 (길이 = 7)

** 솔루션 **

실행 추적:
  [시간 0] 작업 0을 1.00초 동안 실행 (완료)
  [시간 1] 작업 1을 4.00초 동안 실행 (완료)
  [시간 5] 작업 2를 7.00초 동안 실행 (완료)

최종 통계:
  작업 0 -- 응답: 0.00  반환: 1.00  대기: 0.00
  작업 1 -- 응답: 1.00  반환: 5.00  대기: 1.00
  작업 2 -- 응답: 5.00  반환: 12.00  대기: 5.00

  평균 -- 응답: 2.00  반환: 6.00  대기: 2.00
```

그림에서 볼 수 있듯이 -c 플래그는 무슨 일이 일어났는지 보여줍니다. 작업 0은 처음에 1초 동안 실행되었고, 작업 1은 두 번째로 4초 동안, 작업 2는 7초 동안 실행되었습니다. FIFO이기 때문에 어렵지 않습니다! 실행 추적은 이러한 결과를 보여줍니다.

최종 통계도 유용합니다: "응답 시간" (도착 후 처음 실행되기 전까지 대기한 시간), "반환 시간" (처음 도착한 이후 작업을 완료하는 데 걸린 시간), 총 "대기 시간" (준비 상태이지만 실행되지 않은 시간)을 계산합니다. 통계는 각 작업별로 표시되며 모든 작업의 평균으로 표시됩니다. 물론, "-c" 플래그를 사용하기 전에 이러한 것들을 모두 계산했어야 합니다!

다른 입력으로 동일한 유형의 문제를 시도하려면 작업 수나 랜덤 시드 또는 둘 다 변경해보십시오. 다른 랜덤 시드는 기본적으로 무한한 수의 다른 문제를 생성할 수 있는 방법을 제공하며, "-c" 플래그는 자신의 작업을 확인할 수 있게 해줍니다. 개념을 완전히 이해할 때까지 계속 연습하십시오.

또 다른 유용한 플래그는 "-l" (소문자 L)로, 스케줄링할 정확한 작업을 지정할 수 있습니다. 예를 들어, 길이가 5, 10, 15인 세 개의 작업으로 SJF가 어떻게 수행되는지 알고 싶다면 다음을 실행하십시오:

```sh
prompt> ./scheduler.py -p SJF -l 5,10,15
ARG policy SJF
ARG jlist 5,10,15

여기 각 작업의 실행 시간이 포함된 작업 목록이 있습니다:
  작업 0 (길이 = 5.0)
  작업 1 (길이 = 10.0)
  작업 2 (길이 = 15.0)
...
```

그리고 다시 -c를 사용하여 해결할 수 있습니다. 정확한 작업을 지정할 때는 랜덤 시드나 작업 수를 지정할 필요가 없습니다: 작업 길이는 쉼표로 구분된 목록에서 가져옵니다.

물론, SJF (Shortest Job First) 또는 RR (Round Robin) 스케줄러를 사용할 때 더 흥미로운 일이 발생합니다. 시도해보십시오!

그리고 항상 다음을 실행할 수 있습니다:

```sh
prompt> ./scheduler.py -h
```

전체 플래그 및 옵션 목록을 얻을 수 있습니다 (RR 스케줄러의 시간 할당량 설정과 같은 옵션 포함).
